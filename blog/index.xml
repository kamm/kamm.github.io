<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on kamm</title>
    <link>https://kamm.github.io/blog/</link>
    <description>Recent content in Blogs on kamm</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Kamil Mętrak</copyright>
    <lastBuildDate>Mon, 22 May 2023 21:10:15 +0100</lastBuildDate>
    
	<atom:link href="https://kamm.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Instalacja klastra OKD/Openshift </title>
      <link>https://kamm.github.io/2023/05/okd/</link>
      <pubDate>Mon, 22 May 2023 21:10:15 +0100</pubDate>
      
      <guid>https://kamm.github.io/2023/05/okd/</guid>
      <description>Wstęp Do nauki OpenShifta potrzebowałem jakiejś instacji deweloperskiej &amp;ldquo;do psucia&amp;rdquo;. Głowne założenia - wsyztko musi być na maszynach wirtualnych, do uruchomienia na VirtualBoksie lub VMWare Workstation. Klaster ma składać się z 3 wezłów typu Control Plane (w dalszej części będę je nazywał master), które też obsługuja ruch aplikacyjny - czyli nie ma osobnych Compute Node. Takie rozwiązanie będzie odzwierciedlało klaster OpenShifta, na którym pracuję w firmie, ale ten mogę łatwiej psuć.</description>
    </item>
    
    <item>
      <title>Linux - historia prawdziwa</title>
      <link>https://kamm.github.io/2021/04/linux-historia-prawdziwa/</link>
      <pubDate>Thu, 22 Apr 2021 15:56:15 +0200</pubDate>
      
      <guid>https://kamm.github.io/2021/04/linux-historia-prawdziwa/</guid>
      <description>Tym razem będzie bardziej blognotka. Wielokrotnie byłem określany jako &amp;ldquo;ten windowsiarz&amp;rdquo;, co dla osób, które znają mnie trochę dłużej będzie zdziwieniem. Ale może po kolei.
Gdy zacząłem studia najpopularniejszymi systemami były 2 windowsy - 98 i 2000 (o ME chyba wszyscy chcą zapomnieć). Był to rok 2001, czyli chwila przed pojawieniem się XP. Z linuksem (dobra, GNU/Linux) miałem minimalne doświadczenie - próbowałem używać wcześniej RedHata (5.1 Manhattan), Monkey Linux, był też Mandrake Linux, ale tak jakoś nigdy w ten temat głębiej nie wszedłem.</description>
    </item>
    
    <item>
      <title>Suckless po mojemu</title>
      <link>https://kamm.github.io/2021/04/suckless-po-mojemu/</link>
      <pubDate>Tue, 20 Apr 2021 20:18:00 +0200</pubDate>
      
      <guid>https://kamm.github.io/2021/04/suckless-po-mojemu/</guid>
      <description>Tym razem znów o narzędziach z których korzystam. Zacznę od tego jak na to trafiłem. Oglądałem sobie tak z nudów youtuba i wpadł mi film Zmasło o tym, że zainstalował archa. Wtedy jeszcze nie byłem przekonany do tej dystrybucji, ale przejrzałem sobie co on tam ma - tiling managery do mnie nie przemawiają, ale zainteresował mnie st - simple terminal (lub jak inni wolą mowić suckless terminal). Zacząłem się interesować narzędziami suckless i miałem trochę mieszane uczucia.</description>
    </item>
    
    <item>
      <title>screen - manager okien w terminalu tekstowym</title>
      <link>https://kamm.github.io/2021/04/screen/</link>
      <pubDate>Tue, 13 Apr 2021 16:37:15 +0200</pubDate>
      
      <guid>https://kamm.github.io/2021/04/screen/</guid>
      <description>Cześć.
Od czasu pojawienia się koronawirusa cała moja praca odbywa się zdalnie. Niestety, wiele osób narzeka na stabilność VPNa - tym się nie będę zajmował ani wnikał w powody i propozycje rozwiązania. Zaproponuję pewną protezę, która pomoże w tym przypadku a jednocześnie da kilka innych możliwości pracy na systemach uniksowych.
Generalnie pomysł jest prosty i jest obecny np. przy połączeniu pulpitem zdalnym - czyli gdy zostanie zerwane połączenie sieciowe z serwerem to sesja jest odłączana a nie zrywana.</description>
    </item>
    
    <item>
      <title>Programowanie kart inteligentnych - część 2 - komunikacja</title>
      <link>https://kamm.github.io/2018/05/javacard-2/</link>
      <pubDate>Fri, 25 May 2018 08:54:15 +0200</pubDate>
      
      <guid>https://kamm.github.io/2018/05/javacard-2/</guid>
      <description>W poprzednim odcinku utworzyłem bardzo prosty aplet na karcie i wywołałem go z poziomu gpshell. Jednak to jest dobre do testów. W końcu karta ma być wykorzystywana w kryptografii w konkretnej aplikacji.
Stworzyłem bardzo prostego klienta do apletu - jcapp1client. Aplikacja łączy się z pierwszy z brzegu czytnikiem, wybiera kartę do niego włożoną, wybiera aplet i wywołuje instrukcję B0 01. Nawet bez żadnego sprawdzania błędów, kodów wyjścia, nic. Prościej się chyba nieda.</description>
    </item>
    
    <item>
      <title>Programowanie kart inteligentnych - część 1 - pierwszy program</title>
      <link>https://kamm.github.io/2018/05/javacard-1/</link>
      <pubDate>Wed, 23 May 2018 10:52:15 +0200</pubDate>
      
      <guid>https://kamm.github.io/2018/05/javacard-1/</guid>
      <description>Czas zacząć programować. Karty, które mnie intereują i które zamówiłem programuje się w Javie. Są też inne, chyba dotnetowe, ale się nie znam. Zajmę się tylko kartami javoskimi, a dokładniej będę uzywał Java Card Kit w wersji 2.2.2. Do pobrania ze strony Oracla: JavaCard SDK.
Programy wgrane na kartę są apletami, ale nie ma to nic (poza nazwą) związku z java.applet.Applet. Tu mamy javacard.framework.Applet. Generalnie - javacard jest mocno ograniczoną javą.</description>
    </item>
    
    <item>
      <title>Programowanie kart inteligentnych - część 0 - inicjalizacja</title>
      <link>https://kamm.github.io/2018/05/javacard-0/</link>
      <pubDate>Tue, 22 May 2018 11:02:15 +0100</pubDate>
      
      <guid>https://kamm.github.io/2018/05/javacard-0/</guid>
      <description>&lt;p&gt;Zaczynam naukę programowania kart inteligentnych. Są to karty do przechowywania kluczy kryptograficznych, certyfikatów a także innych danych. Do tego celu potrzebowałem zamówić kilka takich kart.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ack</title>
      <link>https://kamm.github.io/2016/12/ack/</link>
      <pubDate>Tue, 27 Dec 2016 21:10:15 +0100</pubDate>
      
      <guid>https://kamm.github.io/2016/12/ack/</guid>
      <description>Przeszukiwanie kodu z konsoli jest problemem. Ja najczęściej używałem dziwnej składni
find . -type f | while read l; do grep -Ri &amp;quot;System.err&amp;quot; $l &amp;amp;&amp;amp; echo $l; done  Działać działa, ale jest nieeleganckie, nieefektywne, ma brzydkie wyjście, dużo błędnych wystąpień (pliki binarne, pliki gita/svna). Słowem - szybki hack.
Ze względu na moje lenistwo nie chciało mi się szukać niczego innego, a okazało się że było warto. O acku dowiedziałem się z prezentacji babuna.</description>
    </item>
    
    <item>
      <title>Babun - windowsowy shell w którym się zakochasz</title>
      <link>https://kamm.github.io/2016/11/babun-shell-w-ktorym-sie-zakochasz/</link>
      <pubDate>Tue, 29 Nov 2016 19:30:51 +0100</pubDate>
      
      <guid>https://kamm.github.io/2016/11/babun-shell-w-ktorym-sie-zakochasz/</guid>
      <description>Shell jest narzędziem potrzebnym w pracy chyba każdemu programiście. Oczywiście, wiele IDE już próbowało zmienić to podejście integrując narzędzia do postaci klikanych rozwiązań, integracji gita czy mavena do edytora, ale nadal stary, poczciwy shell ma się dobrze. Jednak pojawia się pewne &amp;ldquo;ale&amp;rdquo;. Używanie w windowsie cmd jest problematyczne - kopiowanie i wklejanie jest bardzo utrudnione, zaznaczenie tekstu jeszcze bardziej a obsługa historii wywołań jest na szczątkowym poziomie. Podobno powershell wiele z tych rzeczy rozwiązuje, ale i tak - unixowy shell jest tym, co programiści lubią.</description>
    </item>
    
    <item>
      <title>Deweloperski Datapower</title>
      <link>https://kamm.github.io/2016/11/deweloperski-datapower/</link>
      <pubDate>Wed, 23 Nov 2016 22:35:52 +0100</pubDate>
      
      <guid>https://kamm.github.io/2016/11/deweloperski-datapower/</guid>
      <description>Datapower to XML Appliance. Zresztą mniejsza z tym co to jest, bo sam pewnie nie ogarniam wszystkich jego zastosowań i możliwości. Z mojej strony jest wykorzystywany jako środowisko do tworzenia wydajnych usług w oparciu o XSLT. Wszystko fajnie, ale pozostaje kwestia uruchomienia. Na maszynie fizycznej? Marnie - tam jest m. in. produkcja i nikt mi nie pozwoli robić tam developmentu. Na maszynie wirtualnej - spoko, mamy jedną sztukę licencji na wirtualkę.</description>
    </item>
    
    <item>
      <title>Zaczynamy</title>
      <link>https://kamm.github.io/2016/11/zaczynamy/</link>
      <pubDate>Wed, 23 Nov 2016 21:06:00 +0000</pubDate>
      
      <guid>https://kamm.github.io/2016/11/zaczynamy/</guid>
      <description>A w zasadzie to ponownie zaczynam. Postanowiłem ponownie utworzyć tego bloga i zacząć wreszcie coś pisać. Brakowało mi miejsca gdzie mógłbym coś napisać, a miałem co więc tak wyszło. Będę starał się pisać technicznie, ale nie mogę tego zagwarantować - czasem może wyjść coś z życia innego niż tylko kodowanie :)</description>
    </item>
    
  </channel>
</rss>